# Advent of Code 2025 Solutions

Table of Contents
-----------------
- [Day 1 - Secret Entrance][d01]
- [Day 2 - Gift Shop][d02]
- [Day 3 - Lobby][d03]
- [Day 4 - Printing Department][d04]
- [Day 5 - Cafeteria][d05]
- [Day 6 - Trash Compactor][d06]
- [Day 7 - Laboratories][d07]
- [Day 8 - Playground][d08]
- [Day 9 - Movie Theater][d09]


Day 1: Secret Entrance
----------------------
### Part 1
We are asked to perform a series of rotations and count the number of times we land on 0. I used the modulo operator and with every rotation I checked if `current position % 99 == 0` and incremented a count.

### Part 2
In this part we need to find out everytime a rotation passes over 0. The circular mindset got me confused. Instead I looked at the rotations as if there is a linear line. Each rotation moves along a flat line from left to right. The line can be segmented into sections of length `99` and then just apply the rotations seuqntially and determine which segment we end up in starting from segment 0. The difference between the previous segment and current segment will tell if we crossed a 0 or not. Sum up these counts.

There is a tricky situation with the boundary condition when dealing with left turns. This can happen:

```
current position: 102
perform L2
new position: 100

current segment: 1
new segment: 1

but we are actually on 100 which counts as a 0.
```

To deal with this simply deduct 1 from the current and new positions when performing left operations.


Day 2: Gift Shop
----------------------
### Part 1

We need to determine if a given number from a range has a patterns that is repeated twice. A simple implementation is to iterate each range and for each number split in half and compare if the halves are equal. 

### Part 2
I used the same solution but then chunked each number in all lengths starting from 1 upto mid. Because this approach requires iterating each range and since the nunbers are quite large it can take time. Suprisingly the solution also worked for part 2 but took 8 seconds.

Then I realized a repeating pattern can actually be generated. I know the maximum value and its length among all the ranges. If I iterate from 1 upto the largest value which its length does not exceed the maximum length when repeated twice then I can find out all the invalid IDs and check which ones fall into any given range. This brought the runtime to under 1 second.

For example:
```
max value = 1000

tha largest possible value must have length 2, any number from 1 to 99 when repeated twice could be a fake id and it is less than 1000.

1 -> 1, 11, 111, 1111
2 -> 2, 22, 222, 2222
...
10 -> 10, 1010, 101010
11 -> 11, 111, 1111 # this is actual a pattern already generated by 1
12 -> 12, 1212, 121212
```

We can optimize this approach with two modifications:

1) Avoid overhsooting the generated ids when `> max value`, so in the example we shouldn't be generating `1111, 2222, 1010, 1212, ...`.
2) Only use atomic seeds. Given a seed, we can detect if it already has a repeating pattern, if it does then its already generated by an atomic seed, for example `11, 1111` are both already considered with seed `1`, so we can skip these.

With these optimizations runtime was 0.20 seconds.


Day 3: Lobby
----------------------
# Part 1
We are asked to find the largest pair of indices in order. Iterating down from 9 to 1 for the first position I then searched for the largest value for the second position. Runtime is `O(N^2)`.

# Part 2
Now we need to find 12 batteries, and my approach from part 1 was doomed. It would require `O(N^12)` with 12 nested loops.

Instead, I restricted the range I could pick each digit and looked for the maximum value in that range. For example:

```
8  1  1  1  1  1  1  1  1  1  1  1  1  1  9
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

p: the digit being picked, 1st digit, 2nd digit etc.

p   remaining
0   11
1   10
2   9
3   8
...
```

This means for the first digit I can only look at a range 0..3 because picking the first digit at index 4 would mean there is not enough left to pick the remaining 11 digits.

At the start we can pick the first digit from any of the O positions.
As I pick digits, I get closer to the end. It looks like this:

```
OOOO-----------
```

Picking the 1st digit:

```
OxOO-----------
```

Now, I need to pick 11 more digits and I can only start after the 1st digit, so index 2:

```
--OOOO---------
```

I pick the 3rd idx:

```
--OxOO---------
```

The same procedure repeats for the 4th digits and so on. I always need to cut off the remaining digits that I need from the length to ensure I don't run out of digits to pick:

```
remaining = n - p -1 # -1 for the 0 index
end = len(line) - remaining

```


Day 4: Printing Department
--------------------------
# Part 1
We are asked to find all the rolls we can remove. A roll can be removed if there are less than four rolls in its neighborhood. Iterate the grid, for every roll position check all adjacent neighbors, if count is less than 4 include it for removal. Runtime is `O(NM)`.

# Part 2
We now need to remove as many rolls as possible. My first implementation used the solution from part 1 and executed it in a while loop until there was nothing to remove anymore. It worked but was a bit slow because runtime was `O(NMK)`.

Instead of visiting every cell with every iteration I did one initial count of all the rolls then I picked a spot and decremented all its roll neighbors in the count by 1. If any neighbor ended up with a count less than 4 I added it to the queue. This means I only have items in the queue that are going to be removed and while I process these items I update all their neighbors. This has better performance because runtime is `O(NM)`, as I need to process each position at most once.


Day 5: Cafeteria
----------------
# Part 1
We are asked to find fresh ingredients by comparing their ids to the ranges. I iterated the ids and checked if it falls within any region. Runtime is `O(N)` because the checks are all arithmetic operations and I iterate the list of IDs once.

# Part 2
We are now required to find all the fresh ingredients by ignoring the list of the ids and just use the ranges. We can do this by first sorting the ranges using their start point. This aligns all the ranges from their left side. We then pick the first range and call it our current range, there are two cases:

1) The current range will overlap with the next range in which case we can merge these two
2) The current range is disjoint with the next one. This means it is also disjoint with any other range, because the list is sorted.

This way we merge as many ranges together as possible and then simple arithmetic gives us the count. Runtime is `O(N)` because we iterate the ranges once.


Day 6 - Trash Compactor
-----------------------
# Part 1
We are asked to take the numbers in each column and then apply the operation at the bottom. I parsed the input into numbers and operations, and then started iterating column by column, collecting all the numbers and performing the op. Runtime is `O(NM)`.

# Part 2
Similar challenge but now each column contains 1 or more numbers that are aligned also in a column. The input is already stacking up all the numbers so there is no need for padding or anything like that. Also to preserve this alignment we shouldn't be performing any splits on whitespace.

We use a two pointer approach to traverse the rows and columns, collecting each number. Everytime we collect a column that all its numbers are whitespace we know that is the start of a new operation, so we also advance a pointer to our ops list. Runtime is still `O(NM)` because we traverse the entire grid once.

Day 7 - Laboratories
--------------------
# Part 1
We are asked to determine how many times a split has occured. We process the input row by row and we only care about the beams in each column. We use a set of `current_beams` starting with the `S` column, then we process the next row, if that column corresponds to a `.` nothing happens the beam continue to travel on the same column. But, if the next row is a splitter the beam will split in two `(col - 1), (col + 1)`. Then these will be the active beams to process for the next row. Runtime is `O(NM)` if there is a splitter in each column.

# Part 2
Now each split corresponds to a new timeline and we need to find all the timelines. Now when we process the splitters in each row we have to accumulate all the beams arriving at the splitter. As we reach the last row, the sum of all the beam counts are the total timelines.


Day 8 - Playground
-------------------
# Part 1
We are asked to merge junction boxes to form circuits and then find the top largest circuits. This reminded me immediately of union find algorithm. To begin with I formed all the point pairs with their associated distance. Then I sliced the first 1000 pairs and passed it into the union find. The ouptput is a list of ids which I passed into a counter to calculate their sizes. Runtime is `O(N^3)`, with `N` points we have `O(N^2)` pairs, and for each pair we might need to change `N` ids, giving `O(N^3)`.

# Part 2
Its a slight modification of part 1, we now need to find the last pair that connects everything together. I keep running the union find algorithm until all the returned ids are the same which means everything is now connected. The same runtime as part 1, because we considered all pairs and all points when instead of a slice.


Day 9 - Movie Theater
---------------------
# Part 1
We need to find the rectangle with the largest area. Simply check all pairs of red tiles, calculate the associated area, sort from high to low and pick the first item.
Runtime is `O(N^2)`.

# Part 2
Some rectangles are invalid because they contain neither red nor green tiles. I first approached the problem using a dynamic programming solution. The main idea was:

- Find the boundary
- Create a grid
- Create a table of prefix sums in 2D where each entry of the table contains the total number of tiles that are not green or red for a rectangle with one corner at `(0, 0)` and another corner at `(x, y)`.
- Find all the pairs, and for each rectangle check the sum `top slice - left slice + top left corner == 0`, this means the rectangle is free from outside tiles.

Problem was runtime, to make the grid and the DP table I would need to iterate from `xmin -> xmax` and `ymin -> ymax`, with these inputs, we would need a grid of around `100000 x 100000` which is around `10 billion` cells and that will require lots of RAM.

I ditched the DP approach and focused on a geometrical solution.
For every possible pair of red tiles if the following rules are satisfied, it means that rectangle is valid, I can calculate its area and compare it to the max area I have so far.

## Rule 1: Does the rectangle crosses any boundary segments?
If the rectangle crosses any of the boundary segments in the form of a `+` (cross intersection) then we know this rectangle is invalid.

## Rule 2: Is the rectangle trapped inside the walls of the boundary?
It can happen that we have a hollow shape and the rectangle is trapped inside, in which case rule 1 does not fail but the rectangle is clearly invalid.

```
    ---------------
    |  ---------  |
    |  |       |  |
    |  |       |  |
    |  ---------  |
    ---------------
```

## Rule 3: Is there any boundary segments inside the rectangle?
Any internal boundary segments means the rectangle will be split from the inside. We know if there is a boundary there will be an inside and an outside, which means there will be invalid tiles inside the rectangle.

It took me several iterations to get all these rules implemented correctly. A few points I found helpful to make all these work:

1) Ensure segments and points are normalized. This means sorted so that segments always go from left to right, and bottom to top.
2) To determine a point is inside, the trick of adding `0.5` to its coordinate helps a lot because it removes considering corner cases since the line extending from the mid point will never overlap with the grid lines.
3) When dealing with segments and points, it is very easy to say relative orientations on the paper, what becomes tricky is how to label the endpoints to make all the comparisons work. For that using min and max helps a lot since it removes the burden of what is point 1, 2, etc.
4) Since each red tile connects to a green tile, the input forms a polygon. In a polygon the number of vertices equals the number of segments, so our runtime will be dependent on the number of segments `N`. We can also see this in the loop that builds the segments:

```python
for i in range(len(red_tiles) - 1): # Runs N - 1 times
    segments.append(make_seg(red_tiles[i], red_tiles[i + 1]))

segments.append(make_seg(red_tiles[0], red_tiles[-1])) # Runs 1 time to wrap
```


The total runtime is:
```
O(N^2) for all the pairs, and then for each pair
    4 x O(N) for rule 1, check 4 segments against all N boundary segments
    1 x O(N) for rule 2, check one center point against all N boundary segments
    1 x O(N) for rule 3, check the midpoint of all N boundary segments against rectangle bounds
    
    # All the rules run sequentially

=  O(N^3)
```



[top]: #advent-of-code-2025-solutions
[d01]: #day-1-secret-entrance
[d02]: #day-2-gift-shop
[d03]: #day-3-lobby
[d04]: #day-4-printing-department
[d05]: #day-5-cafeteria
[d06]: #day-6-trash-compactor
[d07]: #day-7-laboratories
[d08]: #day-8-playground
[d09]: #day-8-movie-theater