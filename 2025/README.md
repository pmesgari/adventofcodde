# Advent of Code 2025 Solutions

Table of Contents
-----------------
- [Day 1 - Secret Entrance][d01]
- [Day 2 - Gift Shop][d02]


Day 1: Secret Entrance
----------------------
### Part 1
We are asked to perform a series of rotations and count the number of times we land on 0. I used the modulo operator and with every rotation I checked if `current position % 99 == 0` and incremented a count.

### Part 2
In this part we need to find out everytime a rotation passes over 0. The circular mindset got me confused. Instead I looked at the rotations as if there is a linear line. Each rotation moves along a flat line from left to right. The line can be segmented into sections of length `99` and then just apply the rotations seuqntially and determine which segment we end up in starting from segment 0. The difference between the previous segment and current segment will tell if we crossed a 0 or not. Sum up these counts.

There is a tricky situation with the boundary condition when dealing with left turns. This can happen:

```
current position: 102
perform L2
new position: 100

current segment: 1
new segment: 1

but we are actually on 100 which counts as a 0.
```

To deal with this simply deduct 1 from the current and new positions when performing left operations.


Day 2: Gift Shop
----------------------
### Part 1

We need to determine if a given number from a range has a patterns that is repeated twice. A simple implementation is to iterate each range and for each number split in half and compare if the halves are equal. 

### Part 2
I used the same solution but then chunked each number in all lengths starting from 1 upto mid. Because this approach requires iterating each range and since the nunbers are quite large it can take time. Suprisingly the solution also worked for part 2 but took 8 seconds.

Then I realized a repeating pattern can actually be generated. I know the maximum value and its length among all the ranges. If I iterate from 1 upto the largest value which its length does not exceed the maximum length when repeated twice then I can find out all the invalid IDs and check which ones fall into any given range. This brought the runtime to under 1 second.

For example:
```
max value = 1000

tha largest possible value must have length 2, any number from 1 to 99 when repeated twice could be a fake id and it is less than 1000.

1 -> 1, 11, 111, 1111
2 -> 2, 22, 222, 2222
...
10 -> 10, 1010, 101010
11 -> 11, 111, 1111 # this is actual a pattern already generated by 1
12 -> 12, 1212, 121212
```

We can optimize this approach with two modifications:

1) Avoid overhsooting the generated ids when `> max value`, so in the example we shouldn't be generating `1111, 2222, 1010, 1212, ...`.
2) Only use atomic seeds. Given a seed, we can detect if it already has a repeating pattern, if it does then its already generated by an atomic seed, for example `11, 1111` are both already considered with seed `1`, so we can skip these.

With these optimizations runtime was 0.20 seconds.


Day 3: Lobby
----------------------
# Part 1
We are asked to find the largest pair of indices in order. Iterating down from 9 to 1 for the first position I then searched for the largest value for the second position. Runtime is `O(N^2)`.

# Part 2
Now we need to find 12 batteries, and my approach from part 1 was doomed. It would require `O(N^12)` with 12 nested loops.

Instead, I restricted the range I could pick each digit and looked for the maximum value in that range. For example:

```
8  1  1  1  1  1  1  1  1  1  1  1  1  1  9
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

p: the digit being picked, 1st digit, 2nd digit etc.

p   remaining
0   11
1   10
2   9
3   8
...
```

This means for the first digit I can only look at a range 0..3 because picking the first digit at index 4 would mean there is not enough left to pick the remaining 11 digits.

At the start we can pick the first digit from any of the O positions.
As I pick digits, I get closer to the end. It looks like this:

```
OOOO-----------
```

Picking the 1st digit:

```
OxOO-----------
```

Now, I need to pick 11 more digits and I can only start after the 1st digit, so index 2:

```
--OOOO---------
```

I pick the 3rd idx:

```
--OxOO---------
```

The same procedure repeats for the 4th digits and so on. I always need to cut off the remaining digits that I need from the length to ensure I don't run out of digits to pick:

```
remaining = n - p -1 # -1 for the 0 index
end = len(line) - remaining

```






[top]: #advent-of-code-2025-solutions
[d01]: #day-1-secret-entrance
[d02]: #day-2-gift-shop