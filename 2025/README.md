# Advent of Code 2025 Solutions

Table of Contents
-----------------
- [Day 1 - Secret Entrance][d01]
- [Day 2 - Gift Shop][d02]
- [Day 3 - Lobby][d03]
- [Day 4 - Printing Department][d04]
- [Day 5 - Cafeteria][d05]
- [Day 6 - Trash Compactor][d06]


Day 1: Secret Entrance
----------------------
### Part 1
We are asked to perform a series of rotations and count the number of times we land on 0. I used the modulo operator and with every rotation I checked if `current position % 99 == 0` and incremented a count.

### Part 2
In this part we need to find out everytime a rotation passes over 0. The circular mindset got me confused. Instead I looked at the rotations as if there is a linear line. Each rotation moves along a flat line from left to right. The line can be segmented into sections of length `99` and then just apply the rotations seuqntially and determine which segment we end up in starting from segment 0. The difference between the previous segment and current segment will tell if we crossed a 0 or not. Sum up these counts.

There is a tricky situation with the boundary condition when dealing with left turns. This can happen:

```
current position: 102
perform L2
new position: 100

current segment: 1
new segment: 1

but we are actually on 100 which counts as a 0.
```

To deal with this simply deduct 1 from the current and new positions when performing left operations.


Day 2: Gift Shop
----------------------
### Part 1

We need to determine if a given number from a range has a patterns that is repeated twice. A simple implementation is to iterate each range and for each number split in half and compare if the halves are equal. 

### Part 2
I used the same solution but then chunked each number in all lengths starting from 1 upto mid. Because this approach requires iterating each range and since the nunbers are quite large it can take time. Suprisingly the solution also worked for part 2 but took 8 seconds.

Then I realized a repeating pattern can actually be generated. I know the maximum value and its length among all the ranges. If I iterate from 1 upto the largest value which its length does not exceed the maximum length when repeated twice then I can find out all the invalid IDs and check which ones fall into any given range. This brought the runtime to under 1 second.

For example:
```
max value = 1000

tha largest possible value must have length 2, any number from 1 to 99 when repeated twice could be a fake id and it is less than 1000.

1 -> 1, 11, 111, 1111
2 -> 2, 22, 222, 2222
...
10 -> 10, 1010, 101010
11 -> 11, 111, 1111 # this is actual a pattern already generated by 1
12 -> 12, 1212, 121212
```

We can optimize this approach with two modifications:

1) Avoid overhsooting the generated ids when `> max value`, so in the example we shouldn't be generating `1111, 2222, 1010, 1212, ...`.
2) Only use atomic seeds. Given a seed, we can detect if it already has a repeating pattern, if it does then its already generated by an atomic seed, for example `11, 1111` are both already considered with seed `1`, so we can skip these.

With these optimizations runtime was 0.20 seconds.


Day 3: Lobby
----------------------
# Part 1
We are asked to find the largest pair of indices in order. Iterating down from 9 to 1 for the first position I then searched for the largest value for the second position. Runtime is `O(N^2)`.

# Part 2
Now we need to find 12 batteries, and my approach from part 1 was doomed. It would require `O(N^12)` with 12 nested loops.

Instead, I restricted the range I could pick each digit and looked for the maximum value in that range. For example:

```
8  1  1  1  1  1  1  1  1  1  1  1  1  1  9
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

p: the digit being picked, 1st digit, 2nd digit etc.

p   remaining
0   11
1   10
2   9
3   8
...
```

This means for the first digit I can only look at a range 0..3 because picking the first digit at index 4 would mean there is not enough left to pick the remaining 11 digits.

At the start we can pick the first digit from any of the O positions.
As I pick digits, I get closer to the end. It looks like this:

```
OOOO-----------
```

Picking the 1st digit:

```
OxOO-----------
```

Now, I need to pick 11 more digits and I can only start after the 1st digit, so index 2:

```
--OOOO---------
```

I pick the 3rd idx:

```
--OxOO---------
```

The same procedure repeats for the 4th digits and so on. I always need to cut off the remaining digits that I need from the length to ensure I don't run out of digits to pick:

```
remaining = n - p -1 # -1 for the 0 index
end = len(line) - remaining

```


Day 4: Printing Department
--------------------------
# Part 1
We are asked to find all the rolls we can remove. A roll can be removed if there are less than four rolls in its neighborhood. Iterate the grid, for every roll position check all adjacent neighbors, if count is less than 4 include it for removal. Runtime is `O(NM)`.

# Part 2
We now need to remove as many rolls as possible. My first implementation used the solution from part 1 and executed it in a while loop until there was nothing to remove anymore. It worked but was a bit slow because runtime was `O(NMK)`.

Instead of visiting every cell with every iteration I did one initial count of all the rolls then I picked a spot and decremented all its roll neighbors in the count by 1. If any neighbor ended up with a count less than 4 I added it to the queue. This means I only have items in the queue that are going to be removed and while I process these items I update all their neighbors. This has better performance because runtime is `O(NM)`, as I need to process each position at most once.


Day 5: Cafeteria
----------------
# Part 1
We are asked to find fresh ingredients by comparing their ids to the ranges. I iterated the ids and checked if it falls within any region. Runtime is `O(N)` because the checks are all arithmetic operations and I iterate the list of IDs once.

# Part 2
We are now required to find all the fresh ingredients by ignoring the list of the ids and just use the ranges. We can do this by first sorting the ranges using their start point. This aligns all the ranges from their left side. We then pick the first range and call it our current range, there are two cases:

1) The current range will overlap with the next range in which case we can merge these two
2) The current range is disjoint with the next one. This means it is also disjoint with any other range, because the list is sorted.

This way we merge as many ranges together as possible and then simple arithmetic gives us the count. Runtime is `O(N)` because we iterate the ranges once.


Day 6 - Trash Compactor
-----------------------
# Part 1
We are asked to take the numbers in each column and then apply the operation at the bottom. I parsed the input into numbers and operations, and then started iterating column by column, collecting all the numbers and performing the op. Runtime is `O(NM)`.

# Part 2
Similar challenge but now each column contains 1 or more numbers that are aligned also in a column. The input is already stacking up all the numbers so there is no need for padding or anything like that. Also to preserve this alignment we shouldn't be performing any splits on whitespace.

We use a two pointer approach to traverse the rows and columns, collecting each number. Everytime we collect a column that all its numbers are whitespace we know that is the start of a new operation, so we also advance a pointer to our ops list. Runtime is still `O(NM)` because we traverse the entire grid once.


[top]: #advent-of-code-2025-solutions
[d01]: #day-1-secret-entrance
[d02]: #day-2-gift-shop
[d03]: #day-3-lobby
[d04]: #day-4-printing-department
[d05]: #day-5-cafeteria
[d06]: #day-5-trash-compactor